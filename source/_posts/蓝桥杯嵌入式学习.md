---
title: 蓝桥杯嵌入式
date : 2025-2-17 12:00:00
description : 转战蓝桥杯嵌入式
categories: 竞赛
sticky : 4
top_img : https://cdn.jsdelivr.net/gh/C29999/P.bed/c1e08a939b6c52de64842ad27d4d6fad.png
cover : https://cdn.jsdelivr.net/gh/C29999/P.bed/c1e08a939b6c52de64842ad27d4d6fad.png
tags : 竞赛
---

## LED

开发板上的电路图
1 ![点亮一个LED](https://cdn.jsdelivr.net/gh/C29999/P.bed/ca3479b74e8483c35070d97aaec84e0e.png)

![芯片引脚配置](https://cdn.jsdelivr.net/gh/C29999/P.bed/b7f16563a6c90933f41c093512f9b8a1.png)

RCC和SYS的作用

RCC：模块负责管理单片机的时钟系统，控制外部和内部时钟源的选择，频率调节，时钟使能
SYS：SYS模块主要负责管理单片机的系统时钟，包括电源管理和复位控制等功能。

用到的HAL库函数

我在点亮一个流水灯的时候出现了一个问题,我给GPIOC8写低电平的时候,LED亮了四个灯

``` C++

void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState);
//功能：配置引脚电平状态
//参数说明：
//GPIOx：端口号 GPIOA,GPIOB,GPIOC
//GPIO_PinStats PinState : GPIO_PIN_SET 设置引脚为高电平

void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
//功能：反转引脚电平状态
void HAL_Delay(uint32_t Delay);
//功能：延迟 Delay 毫秒
```

### 位运算

``` C++

uint_32t ucled=0x02;//00000010
ucled<<8;//表示将ucled左移8位，变成00000010 00000000,对应位GPIOP9

```

关于为什么进行位运算向左移动八位就能实现点亮对应LED如图

![GPIOC](https://cdn.jsdelivr.net/gh/C29999/P.bed/1bd67df49a8465f6c5d87b04c05d4ebb.png)

位运算向左实现流水灯：

``` C++

void Led_Disp(uint8_t ucLed)
{
    HAL_GPIO_WritePin(GPIOC,0XFF<<8,GPIO_PIN_SET)//熄灭所有灯
    HAL_GPIO_WritePin(GPIOC,ucLed<<8,GPIO_PIN_RESET)//点亮指定的灯

}



//解释：0xFF：1111 1111 ，ucled:写低对应的GPIO
//关于为什么他是GPIO点亮，因为是共阳极LED电路

//关于实现流水灯

uint8_t ucLed=0x01;

LED_Disp(ucLed);
HAL_Delay(100);
ucLed<<=1;//
IF(ucLed==0)//判断是否溢出
{ucLed=0x01}//重置

//每次点亮下一个LED，延迟100ms，然后左移一位
```

关于这个代码中if判断为什么当ucled=0x00重置我出现了一个问题
我在定义ucled的类型的时候，定义- uint32所以就会导致0x80向右移过程不会变成0x00

### 系统滴答定时器(SysTick)

``` C++
void SysTick_Handler(void)
{
/* USER CODE BEGIN SysTick_IRQn 0 */
/* USER CODE END SysTick_IRQn 0 */
HAL_IncTick();
/* USER CODE BEGIN SysTick_IRQn 1 */
usled++;//实现usled每隔1ms自增1
/* USER CODE END SysTick_IRQn 1 */
}

```

这是一个嵌入式中断服务函数,在主函数调用HAl_Init()时,会自动配置SysTick定时器

#### 关于如何解决LED引脚占用问题

观察LCD引脚图可以发现，LED和LCD共用一组引脚，所以我们需要将LED的引脚配置为输出模式，而LCD的引脚配置为输入模式。

所以就有了用到LCD时，我们需要把PD2初始状态修改为低电平，使锁存器两端不导通。需要配置LED时，将锁存器
设置为高电平,将PC8~PC15端口状态传送到左侧1Q~8Q,再配置为低电平

模块代码：

``` C++
void display(uint8_t ucLed)
{
    HAL_GPIO_WritePin(GPIOC,0xFF<<8,GPIO_PIN_SET); //熄灭所有LED
    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET); //打开锁存器
    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); //关闭锁存器

    HAL_GPIO_WritePin(GPIOC,ucled<<8,GPIO_PIN_SET); //熄灭所有LED
    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET); //打开锁存器
    HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET); //关闭锁存器
}

```

### 按键

KEY按键电路图

 ![按键电路图](https://cdn.jsdelivr.net/gh/C29999/P.bed/a3cd2fbe0b15db262bd0295475944d9b.png)
  ![按键原理图](https://cdn.jsdelivr.net/gh/C29999/P.bed/d1c8fc5152e648daf04daf9cb6043eba.png)

``` C++

GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
//功能：读取引脚电平状态
//参数说明：
//端口号：GPIOX，端口号 GPIOA,GPIOB,GPIOC
//GPIO_Pin:引脚号
//返回为引脚的高低电平

```

当按键按下的时候返回的是低电平,松开的时候返回的是高电平

按键模块代码：

``` C++

uint8_t Key_Scan(void)
{
uint8_t key_val=0;
if(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0)==GPIO_PIN_RESET)
{
key_val=1;
} 
f(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_1)==GPIO_PIN_RESET)
{
key_val=2;
} 
f(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_2)==GPIO_PIN_RESET)
{
key_val=3;
} 
f(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0)==GPIO_PIN_RESET)
{
key_val=4;
} 
eturn key_val;
}
```

关于输入输出上拉和下拉

上拉:默认电平为高电平
下拉：默认电平低电平
浮空:不连接，悬空状态

#### 按键三行代码

按键的三种状态

``` C++

void Key_Proc(void)
{
key_val = Key_Scan();
key_down = key_val & (key_val ^ key_old);//表示按键按下瞬间
key_up = ~key_val & (key_val ^ key_old);//表示按键松开瞬间
key_old = key_val;
if(key_down==1)
{
//按键1按下，执行相应操作
}
}

```

key_val ^ key_old 会计算当前按键状态与上一状态的异或结果

按键的长按和短按

``` C++
void key_longandshort(void)
{
    uint8_t key_val=key_ReadPin();
    uint8_t key_down=key_val&(key_val^ key_old);
    uint8_t key_up=~key_val&(key_val^key_old);
    key_old=key_val;
    if(key_down)
    {
    usled=0;
    }
    if(key_up)
    {
        if(usled<1000)
        {
            LEDdisplay(0x01);
            HAL_Delay(2000);
            HAL_GPIO_WritePin(GPIOC,0XFF<<8,GPIO_PIN_SET);
        }
        else
        {
        LEDdisplay(0x02);
        HAL_Delay(2000);
        HAL_GPIO_WritePin(GPIOC,0XFF<<8,GPIO_PIN_SET);
        }
    }

}

>关于位运算^: 如果两个对应的位相同,则该位的结果为0；如果不同，结果为1。

### LCD屏幕

sprintf函数可以将其他字符传化为字符串

LCD函数大全

``` C++

void LCD_Init(void);
//功能：清屏，设置整个屏幕颜色

void LCD_SetTextColor(vu16 Color);
//功能：设置字体颜色

void LCD_SetBackColor(vu16 Color);
//功能：设置背景颜色
void LCD_DisplayStringLine(uint16_t Line, uint8_t *ptr);
//功能：在LCD屏幕上显示字符串
//参数line 行号，共十行。0~9
//ptr要显示的字符串，长度为20

//sprintf函数的应用

//(用于显示变量)

```

关于按键的双击

``` C++
void key_doubleandonce(void)
{
    uint8_t key_val=key_ReadPin();
    uint8_t key_down=key_val&(key_val^key_old);
    uint8_t key_up=~key_val&(key_val^key_old);
    uint8_t key_temp;
    uint8_t key_flag=0;
    if(key_up)
    {
        key_temp=key_up;
        if(key_flag==0)
{
            usled2=0;
            key_flag=1;//表示已经松开按下
        }
        else
        {
            key_flag=0;
            }
    }
    if(key_flag==1)
    {
    if(usled2<300)
    {
        if(key_down==1&&key_flag==1)
        {
            //进入这个if判断表示双击，亮起第二个灯
            LEDdisplay(0x02);
        }
            if(key_down==2&&key_flag==2)
        {
            
            LEDdisplay(0x02);
        }
            if(key_down==3&&key_flag==3)
        {
            
            LEDdisplay(0x02);
        }
            if(key_down==4&&key_flag==4)
        {
            LEDdisplay(0x02);
        }
    }
    else{
        if(key_temp==1)
        {
            usled2=0x01;
        }
        if(key_temp==2)
        {
        }
        if(key_temp==2)
        {
        }
        if(key_temp==2)
        {
        }   
        }
}
    }

```

### 串口通信

注意：如果没有配置LCD，设置USART1默认配置的引脚是PC4、PC5，需要手动改为PA9、PA10
串口发送：

``` C++

HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t
Timeout)
功能：串口发送数据
参数：
UART_HandleTypeDef *huart UART句柄 huart1
uint8_t*pData 需要发送的数据
uint16_t Size 发送的字节数
uint32_t Timeout 最大发送时间，发送数据超时退出发送
```

串口接受函数：

```C++
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t*pData, uint16_t Size)
//功能：串口中断接收函数
//参数：
//UART_HandleTypeDef *huart UART句柄 huart1
//uint8_t *pData 接收到的数据存放地址
//uint16_t Size 发送的字节数 为1，每次中断只能接收一个字符

```

***meset函数：***
用于初始化一块内存，将数组全部清零，或者设置为某个特定值
例如：

``` C++

memset(arr, 'A', sizeof(arr));//将arr数组的每个字节设置为'A'

```

***sscanf函数：***

例如

``` C++

#include <stdio.h>

int main() {
    char str[] = "123 456.78 hello";
    int i;
    float f;
    char s[20];

    // 从字符串中解析数据
    int result = sscanf(str, "%d %f %s", &i, &f, s);

    // 输出解析的结果
    if (result == 3) {
        printf("整数: %d\n", i);
        printf("浮点数: %.2f\n", f);
        printf("字符串: %s\n", s);
    } else {
        printf("解析失败\n");
    }

    return 0;
}
```

### 定时器

关于定时器ADCARR,CRRX,CNT的解释：
！[定时器](https://cdn.jsdelivr.net/gh/C29999/P.bed/940661fe287e81f9d5026f3abc15290d.png)
